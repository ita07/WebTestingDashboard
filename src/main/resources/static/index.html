<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Selenium Automation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f9f9f9;
        }
        h1 {
            color: #333;
        }
        .block {
            display: inline-block;
            padding: 10px;
            margin: 5px;
            background-color: #007bff;
            color: white;
            border-radius: 4px;
            cursor: grab;
            user-select: none;
        }
        .block:hover {
            background-color: #0056b3;
        }
        .workspace {
            width: 100%;
            min-height: 150px;
            border: 2px dashed #ccc;
            margin-top: 20px;
            padding: 10px;
            background-color: #fff;
        }
        .workspace .block {
            background-color: #28a745;
            margin: 5px 0;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 20px;
        }
        button:hover {
            background-color: #0056b3;
        }
        #results {
            margin-top: 20px;
            padding: 10px;
            background: #ffffff;
            border: 1px solid #ccc;
            border-radius: 4px;
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 14px;
            min-height: 100px;
        }
        .json-preview {
            margin-top: 20px;
            width: 100%;
            height: 150px;
            font-family: monospace;
            font-size: 14px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            resize: vertical;
        }
        .error-message {
            color: red;
            margin-top: 10px;
        }
        #resultsTable {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        #resultsTable th, #resultsTable td {
            border: 1px solid #ccc;
            padding: 8px;
            text-align: left;
        }
        #resultsTable th {
            background-color: #f2f2f2;
        }
        #resultsTable .success {
            color: green;
        }
        #resultsTable .failure {
            color: red;
        }
    </style>
</head>
<body>
<h1>Selenium Automation</h1>

<!-- Advanced Mode Toggle -->
<div style="margin-bottom: 16px;">
    <label style="font-weight: bold;">
        <input type="checkbox" id="advancedModeToggle" onchange="toggleAdvancedMode()"> Show Advanced Options
    </label>
</div>

<!-- Test Data Management Section -->
<div id="testDataSection">
    <h2>Test Data Management</h2>
    <div class="test-data-form">
        <input type="text" id="testDataName" placeholder="Test Data Name">
        <input type="text" id="testDataDesc" placeholder="Description">
        <textarea id="testDataJson" placeholder="Variables in JSON format:
{
    &quot;username&quot;: &quot;testuser&quot;,
    &quot;password&quot;: &quot;pass123&quot;,
    &quot;url&quot;: &quot;https://example.com&quot;
}" class="json-preview"></textarea>
        <button onclick="saveTestData()">Save Test Data</button>
        <select id="testDataSelect" onchange="loadTestData()">
            <option value="">Select Test Data</option>
        </select>
        <button onclick="updateTestData()">Update Selected</button>
        <button onclick="deleteTestData()">Delete</button>
    </div>
</div>

<!-- Available Actions -->
<div>
    <h3>Available Actions</h3>
    <div id="actionBlocks">
        <div class="block" draggable="true" data-action="navigate">Navigate</div>
        <div class="block" draggable="true" data-action="click">Click</div>
        <div class="block" draggable="true" data-action="type">Type</div>
        <div class="block" draggable="true" data-action="wait">Wait</div>
        <div class="block" draggable="true" data-action="select">Select</div>
        <div class="block" draggable="true" data-action="check">Check</div>
        <div class="block" draggable="true" data-action="uncheck">Uncheck</div>
        <div class="block" draggable="true" data-action="hover">Hover</div>
        <div class="block" draggable="true" data-action="scroll">Scroll</div>
        <div class="block" draggable="true" data-action="upload">Upload</div>
        <div class="block" draggable="true" data-action="assert">Assert</div>
        <div class="block" draggable="true" data-action="doubleclick">DoubleClick</div>
        <div class="block" draggable="true" data-action="draganddrop">DragAndDrop</div>
    </div>
</div>

<!-- Workspace -->
<h3>Workspace</h3>
<div id="workspace" class="workspace"></div>

<!-- JSON Preview -->
<h3>Generated JSON</h3>
<textarea id="jsonPreview" class="json-preview" placeholder="JSON will appear here..."></textarea>
<button onclick="validateJson()">Validate JSON</button>
<div id="errorMessage" class="error-message"></div>

<!-- Run Tests Button and Stop on Failure Toggle -->
<div style="margin-top: 20px; display: flex; align-items: center; gap: 16px;">
    <button id="runTestsButton" onclick="runTests()" disabled>Run Tests</button>
    <label style="margin: 0;"><input type="checkbox" id="stopOnFailure"> Stop on Failure</label>
    <button onclick="window.location.href='/reports-viewer'" style="background-color: #28a745;">View Reports</button>
</div>

<!-- Results -->
<h2>Results:</h2>
<div id="activeRuns" style="margin-bottom: 10px;"></div>
<pre id="results"></pre>

<!-- Test Run History Section -->
<h2>Test Run History</h2>
<button onclick="fetchTestHistory()">Refresh History</button>
<div id="historySection"></div>

<!-- Test Suite Management -->
<h2>Test Suite Management</h2>
<div id="suiteSection">
    <button onclick="fetchSuites()">Refresh Suites</button>
    <select id="suiteSelect"></select>
    <button onclick="loadSuite()">Load</button>
    <button onclick="deleteSuite()">Delete</button>
    <input type="text" id="suiteName" placeholder="Suite Name">
    <input type="text" id="suiteDesc" placeholder="Description">
    <button onclick="saveSuite()">Save as New</button>
    <button onclick="updateSuite()">Update</button>
</div>
<br>

<script>
    // Track blocks in the workspace
    let workspaceBlocks = [];
    let isValidJson = false;

    // Add event listener for stopOnFailure checkbox
    const stopOnFailureCheckbox = document.getElementById('stopOnFailure');
    if (stopOnFailureCheckbox) {
        stopOnFailureCheckbox.addEventListener('change', function() {
            const jsonPreview = document.getElementById('jsonPreview');
            try {
                const parsed = JSON.parse(jsonPreview.value);
                parsed.stopOnFailure = this.checked;
                jsonPreview.value = JSON.stringify(parsed, null, 2);
                validateJson();
            } catch (e) {
                // If JSON is invalid, just trigger normal update
                updateJsonPreview();
            }
        });
    }

    // Add event listeners for drag-and-drop
    document.addEventListener('DOMContentLoaded', () => {
        const actionBlocks = document.querySelectorAll('#actionBlocks .block');
        const workspace = document.getElementById('workspace');

        // Handle drag start
        actionBlocks.forEach(block => {
            block.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', e.target.dataset.action);
            });
        });

        // Handle drag over
        workspace.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        // Handle drop
        workspace.addEventListener('drop', (e) => {
            e.preventDefault();
            const action = e.dataTransfer.getData('text/plain');
            const newBlock = createWorkspaceBlock(action);
            workspace.appendChild(newBlock);

            // Update JSON preview
            updateJsonPreview();

            // Add block to workspaceBlocks array
            workspaceBlocks.push({ action });
        });
    });

    // Create a block in the workspace
    function createWorkspaceBlock(action) {
        const block = document.createElement('div');
        block.className = 'block';
        block.textContent = action.charAt(0).toUpperCase() + action.slice(1); // Capitalize first letter

        // Add a remove button
        const removeButton = document.createElement('button');
        removeButton.textContent = 'X';
        removeButton.style.marginLeft = '10px';
        removeButton.style.padding = '2px 5px';
        removeButton.style.backgroundColor = 'red';
        removeButton.style.color = 'white';
        removeButton.style.border = 'none';
        removeButton.style.borderRadius = '3px';
        removeButton.style.cursor = 'pointer';
        removeButton.onclick = function() {
            block.remove();
            updateJsonPreview(); // Update JSON when a block is removed
        };
        block.appendChild(removeButton);

        // Add fields based on action type
        if (action === 'navigate') {
            const urlInput = document.createElement('input');
            urlInput.type = 'text';
            urlInput.placeholder = 'URL';
            urlInput.oninput = updateJsonPreview;
            block.appendChild(urlInput);
        } else if (action === 'click' || action === 'type' || action === 'check' || action === 'uncheck' || action === 'hover' || action === 'scroll' || action === 'doubleclick') {
            // Locator type dropdown
            const locatorTypeInput = document.createElement('select');
            locatorTypeInput.innerHTML = `
                <option value="id">id</option>
                <option value="name">name</option>
                <option value="xpath">xpath</option>
                <option value="cssSelector">cssSelector</option>
                <option value="className">className</option>
                <option value="tagName">tagName</option>
                <option value="linkText">linkText</option>
                <option value="partialLinkText">partialLinkText</option>
            `;
            locatorTypeInput.onchange = updateJsonPreview;
            block.appendChild(locatorTypeInput);

            const locatorValueInput = document.createElement('input');
            locatorValueInput.type = 'text';
            locatorValueInput.placeholder = 'Locator Value';
            locatorValueInput.oninput = updateJsonPreview;
            block.appendChild(locatorValueInput);

            if (action === 'type') {
                const textInput = document.createElement('input');
                textInput.type = 'text';
                textInput.placeholder = 'Text';
                textInput.oninput = updateJsonPreview;
                block.appendChild(textInput);
            }
            // Timeout input for all relevant actions
            const timeoutInput = document.createElement('input');
            timeoutInput.type = 'number';
            timeoutInput.placeholder = 'Timeout (seconds, optional)';
            timeoutInput.min = '1';
            timeoutInput.style.marginLeft = '10px';
            timeoutInput.oninput = updateJsonPreview;
            timeoutInput.classList.add('advanced-option');
            timeoutInput.style.display = document.getElementById('advancedModeToggle')?.checked ? '' : 'none';
            block.appendChild(timeoutInput);
        } else if (action === 'wait') {
            const secondsInput = document.createElement('input');
            secondsInput.type = 'number';
            secondsInput.placeholder = 'Seconds';
            secondsInput.min = '0';
            secondsInput.oninput = updateJsonPreview;
            block.appendChild(secondsInput);
        } else if (action === 'select') {
            // Locator type dropdown
            const locatorTypeInput = document.createElement('select');
            locatorTypeInput.innerHTML = `
                <option value="id">id</option>
                <option value="name">name</option>
                <option value="xpath">xpath</option>
                <option value="cssSelector">cssSelector</option>
                <option value="className">className</option>
                <option value="tagName">tagName</option>
                <option value="linkText">linkText</option>
                <option value="partialLinkText">partialLinkText</option>
            `;
            locatorTypeInput.onchange = updateJsonPreview;
            block.appendChild(locatorTypeInput);

            const locatorValueInput = document.createElement('input');
            locatorValueInput.type = 'text';
            locatorValueInput.placeholder = 'Locator Value';
            locatorValueInput.oninput = updateJsonPreview;
            block.appendChild(locatorValueInput);

            const selectByInput = document.createElement('input');
            selectByInput.type = 'text';
            selectByInput.placeholder = 'Select By (value, visibleText, index)';
            selectByInput.oninput = updateJsonPreview;
            block.appendChild(selectByInput);

            const optionInput = document.createElement('input');
            optionInput.type = 'text';
            optionInput.placeholder = 'Option';
            optionInput.oninput = updateJsonPreview;
            block.appendChild(optionInput);

            // Timeout input for select
            const timeoutInput = document.createElement('input');
            timeoutInput.type = 'number';
            timeoutInput.placeholder = 'Timeout (seconds, optional)';
            timeoutInput.min = '1';
            timeoutInput.style.marginLeft = '10px';
            timeoutInput.oninput = updateJsonPreview;
            timeoutInput.classList.add('advanced-option');
            timeoutInput.style.display = document.getElementById('advancedModeToggle')?.checked ? '' : 'none';
            block.appendChild(timeoutInput);
        } else if (action === 'upload') {
            // Locator type dropdown
            const locatorTypeInput = document.createElement('select');
            locatorTypeInput.innerHTML = `
                <option value="id">id</option>
                <option value="name">name</option>
                <option value="xpath">xpath</option>
                <option value="cssSelector">cssSelector</option>
                <option value="className">className</option>
                <option value="tagName">tagName</option>
                <option value="linkText">linkText</option>
                <option value="partialLinkText">partialLinkText</option>
            `;
            locatorTypeInput.onchange = updateJsonPreview;
            block.appendChild(locatorTypeInput);

            const locatorValueInput = document.createElement('input');
            locatorValueInput.type = 'text';
            locatorValueInput.placeholder = 'Locator Value';
            locatorValueInput.oninput = updateJsonPreview;
            block.appendChild(locatorValueInput);

            const filePathInput = document.createElement('input');
            filePathInput.type = 'text';
            filePathInput.placeholder = 'File Path';
            filePathInput.oninput = updateJsonPreview;
            block.appendChild(filePathInput);
        } else if (action === 'assert') {
            const conditionInput = document.createElement('input');
            conditionInput.type = 'text';
            conditionInput.placeholder = 'Condition (text, title, elementPresent, etc.)';
            conditionInput.oninput = updateJsonPreview;
            block.appendChild(conditionInput);

            // Locator type dropdown (optional)
            const locatorTypeInput = document.createElement('select');
            locatorTypeInput.innerHTML = `
                <option value="">(none)</option>
                <option value="id">id</option>
                <option value="name">name</option>
                <option value="xpath">xpath</option>
                <option value="cssSelector">cssSelector</option>
                <option value="className">className</option>
                <option value="tagName">tagName</option>
                <option value="linkText">linkText</option>
                <option value="partialLinkText">partialLinkText</option>
            `;
            locatorTypeInput.onchange = updateJsonPreview;
            block.appendChild(locatorTypeInput);

            const locatorValueInput = document.createElement('input');
            locatorValueInput.type = 'text';
            locatorValueInput.placeholder = 'Locator Value (optional)';
            locatorValueInput.oninput = updateJsonPreview;
            block.appendChild(locatorValueInput);

            const expectedInput = document.createElement('input');
            expectedInput.type = 'text';
            expectedInput.placeholder = 'Expected (optional)';
            expectedInput.oninput = updateJsonPreview;
            block.appendChild(expectedInput);

            const attributeInput = document.createElement('input');
            attributeInput.type = 'text';
            attributeInput.placeholder = 'Attribute (optional)';
            attributeInput.oninput = updateJsonPreview;
            block.appendChild(attributeInput);

            // Timeout input for assert
            const timeoutInput = document.createElement('input');
            timeoutInput.type = 'number';
            timeoutInput.placeholder = 'Timeout (seconds, optional)';
            timeoutInput.min = '1';
            timeoutInput.style.marginLeft = '10px';
            timeoutInput.oninput = updateJsonPreview;
            timeoutInput.classList.add('advanced-option');
            timeoutInput.style.display = document.getElementById('advancedModeToggle')?.checked ? '' : 'none';
            block.appendChild(timeoutInput);
        } else if (action === 'draganddrop') {
            // Source locator type dropdown
            const sourceLocatorTypeInput = document.createElement('select');
            sourceLocatorTypeInput.innerHTML = `
                <option value="id">id</option>
                <option value="name">name</option>
                <option value="xpath">xpath</option>
                <option value="cssSelector">cssSelector</option>
                <option value="className">className</option>
                <option value="tagName">tagName</option>
                <option value="linkText">linkText</option>
                <option value="partialLinkText">partialLinkText</option>
            `;
            sourceLocatorTypeInput.onchange = updateJsonPreview;
            block.appendChild(sourceLocatorTypeInput);

            const sourceLocatorValueInput = document.createElement('input');
            sourceLocatorValueInput.type = 'text';
            sourceLocatorValueInput.placeholder = 'Source Locator Value';
            sourceLocatorValueInput.oninput = updateJsonPreview;
            block.appendChild(sourceLocatorValueInput);

            // Target locator type dropdown
            const targetLocatorTypeInput = document.createElement('select');
            targetLocatorTypeInput.innerHTML = `
                <option value="id">id</option>
                <option value="name">name</option>
                <option value="xpath">xpath</option>
                <option value="cssSelector">cssSelector</option>
                <option value="className">className</option>
                <option value="tagName">tagName</option>
                <option value="linkText">linkText</option>
                <option value="partialLinkText">partialLinkText</option>
            `;
            targetLocatorTypeInput.onchange = updateJsonPreview;
            block.appendChild(targetLocatorTypeInput);

            const targetLocatorValueInput = document.createElement('input');
            targetLocatorValueInput.type = 'text';
            targetLocatorValueInput.placeholder = 'Target Locator Value';
            targetLocatorValueInput.oninput = updateJsonPreview;
            block.appendChild(targetLocatorValueInput);

            // Timeout input for draganddrop
            const timeoutInput = document.createElement('input');
            timeoutInput.type = 'number';
            timeoutInput.placeholder = 'Timeout (seconds, optional)';
            timeoutInput.min = '1';
            timeoutInput.style.marginLeft = '10px';
            timeoutInput.oninput = updateJsonPreview;
            timeoutInput.classList.add('advanced-option');
            timeoutInput.style.display = document.getElementById('advancedModeToggle')?.checked ? '' : 'none';
            block.appendChild(timeoutInput);
        }

        return block;
    }

    // Generate JSON from workspace blocks
    function getActionsFromWorkspace() {
        const blocks = document.querySelectorAll('#workspace .block');
        const actions = [];

        blocks.forEach(block => {
            // Ensure we only get the text of the action itself, not the remove button or input placeholders
            const actionTextNode = block.firstChild;
            const action = actionTextNode && actionTextNode.nodeType === Node.TEXT_NODE
                           ? actionTextNode.textContent.trim().toLowerCase()
                           : block.dataset.action; // Fallback if firstChild isn't the expected text node

            const inputs = block.querySelectorAll('input');
            const actionData = { action };

            if (action === 'navigate') {
                actionData.url = inputs[0].value;
            } else if (action === 'click' || action === 'type' || action === 'check' || action === 'uncheck' || action === 'hover' || action === 'scroll' || action === 'doubleclick') {
                actionData.locator = {
                    type: block.querySelector('select').value,
                    value: inputs[0].value
                };
                if (action === 'type') {
                    actionData.text = inputs[1].value;
                    if (inputs[2] && inputs[2].value) {
                        actionData.timeout = parseInt(inputs[2].value);
                    }
                } else {
                    if (inputs[1] && inputs[1].value) {
                        actionData.timeout = parseInt(inputs[1].value);
                    }
                }
            } else if (action === 'wait') {
                actionData.seconds = inputs[0].value;
            } else if (action === 'select') {
                actionData.locator = {
                    type: block.querySelector('select').value,
                    value: inputs[0].value
                };
                actionData.selectBy = inputs[1].value;
                actionData.option = inputs[2].value;
                if (inputs[3] && inputs[3].value) {
                    actionData.timeout = parseInt(inputs[3].value);
                }
            } else if (action === 'upload') {
                actionData.locator = {
                    type: block.querySelector('select').value,
                    value: inputs[0].value
                };
                actionData.filePath = inputs[1].value;
            } else if (action === 'assert') {
                actionData.condition = inputs[0].value;
                actionData.locator = {
                    type: block.querySelector('select').value,
                    value: inputs[1].value
                };
                actionData.expected = inputs[2].value;
                actionData.attribute = inputs[3].value;
                if (inputs[4] && inputs[4].value) {
                    actionData.timeout = parseInt(inputs[4].value);
                }
            } else if (action === 'draganddrop') {
                actionData.sourceLocator = {
                    type: block.querySelectorAll('select')[0].value,
                    value: inputs[0].value
                };
                actionData.targetLocator = {
                    type: block.querySelectorAll('select')[1].value,
                    value: inputs[1].value
                };
                if (inputs[2] && inputs[2].value) {
                    actionData.timeout = parseInt(inputs[2].value);
                }
            }

            actions.push(actionData);
        });

        return actions;
    }

    // Update JSON preview to use the browser from the UI if present, else fallback to 'chrome'
    function updateJsonPreview() {
        const actions = getActionsFromWorkspace();
        let browser = 'chrome';
        let stopOnFailure = document.getElementById('stopOnFailure')?.checked || false;
        let testDataId = document.getElementById('testDataSelect')?.value; // Get current value from dropdown

        // Try to preserve browser and stopOnFailure from existing preview if it's valid JSON
        try {
            const existingPreviewText = document.getElementById('jsonPreview').value;
            if (existingPreviewText) {
                const parsedExistingPreview = JSON.parse(existingPreviewText);
                if (parsedExistingPreview.browser) browser = parsedExistingPreview.browser;
                if (typeof parsedExistingPreview.stopOnFailure === 'boolean') stopOnFailure = parsedExistingPreview.stopOnFailure;
            }
        } catch (e) {
            // Ignore if jsonPreview is not valid JSON, defaults will be used.
        }

        const jsonPreviewTextarea = document.getElementById('jsonPreview');
        const previewObj = { browser, stopOnFailure, actions };

        if (testDataId && testDataId !== "") { // Check if a valid selection (not the placeholder) is made
            previewObj.testDataId = parseInt(testDataId);
        }
        // If testDataId is empty or null (e.g., placeholder selected), it won't be added to previewObj.

        jsonPreviewTextarea.value = JSON.stringify(previewObj, null, 2);
        isValidJson = false; // Force re-validation as preview has changed
        document.getElementById('runTestsButton').disabled = true;
        document.getElementById('errorMessage').textContent = '';
    }

    // Validate JSON
    function validateJson() {
        const jsonPreview = document.getElementById('jsonPreview');
        try {
            const parsed = JSON.parse(jsonPreview.value); // Attempt to parse JSON
            // Check that actions is an array
            if (!parsed.actions || !Array.isArray(parsed.actions)) {
                throw new Error('The root object must have an "actions" array property.');
            }
            // Sync stopOnFailure checkbox
            document.getElementById('stopOnFailure').checked = !!parsed.stopOnFailure;
            isValidJson = true;
            document.getElementById('runTestsButton').disabled = false; // Enable Run Tests button
            document.getElementById('errorMessage').textContent = 'JSON is valid!';
        } catch (error) {
            isValidJson = false;
            document.getElementById('runTestsButton').disabled = true; // Disable Run Tests button
            document.getElementById('errorMessage').textContent = 'Invalid JSON: ' + error.message;
        }
    }

    // Track active test runs and their cancel buttons
    let activeRuns = [];

    // Add a function to render active runs and cancel buttons
    function renderActiveRuns() {
        const activeRunsDiv = document.getElementById('activeRuns');
        if (!activeRunsDiv) return;
        activeRunsDiv.innerHTML = '';
        activeRuns.forEach(run => {
            const runDiv = document.createElement('div');
            runDiv.style.display = 'inline-block';
            runDiv.style.marginRight = '10px';
            runDiv.style.marginBottom = '5px';
            runDiv.style.padding = '6px 10px';
            runDiv.style.background = '#f2f2f2';
            runDiv.style.border = '1px solid #ccc';
            runDiv.style.borderRadius = '4px';
            runDiv.style.fontWeight = 'bold';
            runDiv.textContent = `Test Run #${run.id} `;
            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel';
            cancelBtn.style.background = '#dc3545';
            cancelBtn.style.color = 'white';
            cancelBtn.style.border = 'none';
            cancelBtn.style.borderRadius = '3px';
            cancelBtn.style.marginLeft = '8px';
            cancelBtn.style.cursor = 'pointer';
            cancelBtn.onclick = async function() {
                cancelBtn.disabled = true;
                cancelBtn.textContent = 'Cancelling...';
                try {
                    const res = await fetch(`/api/tests/cancel/${run.id}`, { method: 'POST' });
                    if (res.ok) {
                        runDiv.textContent = `Test Run #${run.id} cancelled.`;
                        setTimeout(() => {
                            activeRuns = activeRuns.filter(r => r.id !== run.id);
                            renderActiveRuns();
                        }, 1500);
                    } else {
                        cancelBtn.textContent = 'Failed';
                    }
                } catch {
                    cancelBtn.textContent = 'Failed';
                }
            };
            runDiv.appendChild(cancelBtn);
            activeRunsDiv.appendChild(runDiv);
        });
    }

    // Run tests
    async function runTests() {
        if (!isValidJson) {
            alert('Please validate the JSON before running tests.');
            return;
        }

        const jsonPreview = document.getElementById('jsonPreview');
        const payload = JSON.parse(jsonPreview.value);
        const resultsDiv = document.getElementById('results');
        resultsDiv.textContent = 'Running test...';
        let testRunId; // Declare testRunId here to be accessible in catch/finally

        try {
            // Submit the test
            const response = await fetch('/api/tests/run', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorData = await response.json();
                resultsDiv.textContent = `Error: ${response.status} ${response.statusText}\\\\n${errorData.message}`;
                return;
            }

            const data = await response.json();
            testRunId = data.testRunId; // Assign here

            if (!testRunId) {
                resultsDiv.textContent = 'Error: No test run ID returned from server';
                return;
            }

            // Add to active runs and render
            activeRuns.push({ id: testRunId });
            renderActiveRuns();

            resultsDiv.textContent = `Test run #${testRunId} submitted. Initial check in 5 seconds...`;

            // Initial delay
            await new Promise(resolve => setTimeout(resolve, 5000)); // 5 seconds

            const maxPollAttempts = 595; // Increased from 175 to 595 (approx 10 minutes total polling after initial delay)
            let pollAttempts = 0;

            while (pollAttempts < maxPollAttempts) {
                resultsDiv.textContent = `Test run #${testRunId} in progress... Checking results (attempt ${pollAttempts + 1}/${maxPollAttempts})...`;
                let resultResponse;
                try {
                    resultResponse = await fetch(`/api/tests/results/${testRunId}`);
                } catch (networkError) {
                    console.error(`Network error polling for testRunId ${testRunId}:`, networkError);
                    if (pollAttempts >= maxPollAttempts - 1) { // Last attempt
                        resultsDiv.textContent = `Network error on final attempt to get results for test run #${testRunId}.`;
                        return; // Keep in activeRuns for potential manual cancel
                    }
                    resultsDiv.textContent = `Network error polling for test run #${testRunId}. Retrying...`;
                    pollAttempts++;
                    await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2 seconds before retrying on network error
                    continue;
                }

                if (!resultResponse.ok) {
                    console.warn(`Polling for testRunId ${testRunId}: HTTP Status ${resultResponse.status}.`);
                     if (pollAttempts >= maxPollAttempts - 1) { // Last attempt
                        resultsDiv.textContent = `Server error (status ${resultResponse.status}) on final attempt for test run #${testRunId}.`;
                        return; // Keep in activeRuns
                    }
                    resultsDiv.textContent = `Server error (status ${resultResponse.status}) polling for test run #${testRunId}. Retrying...`;
                    pollAttempts++;
                    await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2 seconds before retrying on server error
                    continue;
                }

                const resultData = await resultResponse.json();

                if (resultData.results) {
                    displayResults(resultData.results, resultsDiv);
                    activeRuns = activeRuns.filter(r => r.id !== testRunId);
                    renderActiveRuns();
                    return; // Success
                } else if (resultData.status === 'running' || resultData.status === 'queued') {
                    // Test is still running or queued, continue polling. Message is updated at loop start.
                } else if (resultData.status === 'not_found') {
                    if (pollAttempts < 8) { // Changed from 3 to 8: Allow more retries if 'not_found' appears early
                        console.warn(`Test run #${testRunId} status 'not_found'. Retrying poll (${pollAttempts + 1}/${maxPollAttempts})...`);
                    } else {
                        resultsDiv.textContent = `Results for test run #${testRunId} not found after multiple attempts. Test may have failed or results already cleared.`;
                        activeRuns = activeRuns.filter(r => r.id !== testRunId);
                        renderActiveRuns();
                        return;
                    }
                } else {
                    // Unknown status from payload
                    resultsDiv.textContent = `Test run #${testRunId} has an unknown status: '${resultData.status}'.`;
                    activeRuns = activeRuns.filter(r => r.id !== testRunId);
                    renderActiveRuns();
                    return;
                }

                pollAttempts++;
                await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second for next regular poll
            }

            resultsDiv.textContent = `Timeout waiting for results of test run #${testRunId}. The test may still be running. You can try to cancel it.`;
            // Do not remove from activeRuns here, so cancel button remains

        } catch (error) {
            resultsDiv.textContent = `Error: ${error.message}`;
            // If an error occurs (e.g., network issue before or during polling)
            // and we have a testRunId, it implies it might be active on server.
            // The existing logic for cancel button to remain on timeout or error seems fine.
            // If error is before testRunId is obtained, activeRuns is not affected.
        }
    }

    // Function to display test results
    function displayResults(results, resultsDiv) {
        if (Array.isArray(results)) {
            let html = '<table id="resultsTable">';
            html += '<tr><th>Action</th><th>Status</th><th>Message</th><th>Time (s)</th><th>Screenshot</th></tr>';
            results.forEach(r => {
                html += `<tr><td>${r.action}</td><td class="${r.status}">${r.status}</td><td>${r.message}</td>`;
                if (typeof r.executionTimeMillis === 'number') {
                    html += `<td>${(r.executionTimeMillis / 1000).toFixed(2)}</td>`;
                } else {
                    html += '<td>N/A</td>';
                }
                if (r.screenshotPath) {
                    let screenshotUrl = r.screenshotPath;
                    if (screenshotUrl.startsWith('screenshots/')) {
                        screenshotUrl = '/' + screenshotUrl.replace(/\\/g, '/');
                    }
                    const fileName = screenshotUrl.split('/').pop();
                    html += `<td><a href="${screenshotUrl}" target="_blank" download="${fileName}">View Screenshot</a></td>`;
                } else {
                    html += '<td>N/A</td>';
                }
                html += '</tr>';
            });
            html += '</table>';
            resultsDiv.innerHTML = html;
        } else {
            resultsDiv.textContent = JSON.stringify(results, null, 2);
        }
    }

    // Fetch and display test run history
    async function fetchTestHistory() {
        const historySection = document.getElementById('historySection');
        historySection.textContent = 'Loading...';
        try {
            const response = await fetch('/api/tests/history');
            if (!response.ok) {
                historySection.textContent = `Error: ${response.status} ${response.statusText}`;
                return;
            }
            const history = await response.json();
            if (!Array.isArray(history) || history.length === 0) {
                historySection.textContent = 'No test runs found.';
                return;
            }
            let html = '<table id="historyTable">';
            html += '<tr><th>ID</th><th>Browser</th><th>Executed At</th><th>Actions</th><th>Results</th></tr>';
            history.forEach(run => {
                html += `<tr>`;
                html += `<td>${run.id}</td>`;
                html += `<td>${run.browser}</td>`;
                html += `<td>${run.executedAt ? run.executedAt.replace('T', ' ').substring(0, 19) : ''}</td>`;
                html += `<td><button onclick='showJsonModal(${JSON.stringify(run.actionsJson)}, "Actions")'>View</button></td>`;
                html += `<td><button onclick='showJsonModal(${JSON.stringify(run.resultsJson)}, "Results")'>View</button></td>`;
                html += `</tr>`;
            });
            html += '</table>';
            historySection.innerHTML = html;
        } catch (error) {
            historySection.textContent = `Error: ${error.message}`;
        }
    }

    // --- Test Suite Management ---
    async function fetchSuites() {
        const select = document.getElementById('suiteSelect');
        select.innerHTML = '';
        try {
            const res = await fetch('/api/suites');
            if (!res.ok) return;
            const suites = await res.json();
            suites.forEach(suite => {
                const opt = document.createElement('option');
                opt.value = suite.id;
                opt.textContent = `${suite.name} (${suite.id})`;
                select.appendChild(opt);
            });
        } catch {}
    }
    async function loadSuite() {
        const select = document.getElementById('suiteSelect');
        if (!select.value) return;
        const res = await fetch(`/api/suites/${select.value}`);
        if (!res.ok) return;
        const suite = await res.json();
        document.getElementById('suiteName').value = suite.name || '';
        document.getElementById('suiteDesc').value = suite.description || '';
        // Load actionsJson into workspace and JSON preview
        try {
            const parsed = JSON.parse(suite.actionsJson);
            document.getElementById('jsonPreview').value = JSON.stringify(parsed, null, 2);
            validateJson();
        } catch {}
    }
    async function saveSuite() {
        const name = document.getElementById('suiteName').value;
        const desc = document.getElementById('suiteDesc').value;
        const actionsJson = document.getElementById('jsonPreview').value;
        if (!name || !actionsJson) return alert('Name and actions required');
        const payload = { name, description: desc, actionsJson };
        const res = await fetch('/api/suites', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
        if (res.ok) { fetchSuites(); alert('Suite saved!'); }
        else alert('Failed to save suite');
    }
    async function updateSuite() {
        const select = document.getElementById('suiteSelect');
        if (!select.value) return;
        const name = document.getElementById('suiteName').value;
        const desc = document.getElementById('suiteDesc').value;
        const actionsJson = document.getElementById('jsonPreview').value;
        if (!name || !actionsJson) return alert('Name and actions required');
        const payload = { name, description: desc, actionsJson };
        const res = await fetch(`/api/suites/${select.value}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
        if (res.ok) { fetchSuites(); alert('Suite updated!'); }
        else alert('Failed to update suite');
    }
    async function deleteSuite() {
        const select = document.getElementById('suiteSelect');
        if (!select.value) return;
        if (!confirm('Delete this suite?')) return;
        const res = await fetch(`/api/suites/${select.value}`, { method: 'DELETE' });
        if (res.ok) { fetchSuites(); alert('Suite deleted!'); }
        else alert('Failed to delete suite');
    }
    // --- End Test Suite Management ---

    // Modal to show JSON (actions/results)
    function showJsonModal(jsonString, title) {
        let modal = document.getElementById('jsonModal');
        if (!modal) {
            modal = document.createElement('div');
            modal.id = 'jsonModal';
            modal.style.position = 'fixed';
            modal.style.top = '0';
            modal.style.left = '0';
            modal.style.width = '100vw';
            modal.style.height = '100vh';
            modal.style.background = 'rgba(0,0,0,0.5)';
            modal.style.display = 'flex';
            modal.style.alignItems = 'center';
            modal.style.justifyContent = 'center';
            modal.style.zIndex = '1000';
            document.body.appendChild(modal);
        }
        modal.innerHTML = `<div style='background:#fff;padding:20px;border-radius:8px;max-width:80vw;max-height:80vh;overflow:auto;'>
            <h3>${title}</h3>
            <pre style='white-space:pre-wrap;max-width:70vw;max-height:60vh;overflow:auto;'>${formatJson(jsonString)}</pre>
            <button onclick='document.getElementById("jsonModal").remove()'>Close</button>
        </div>`;
    }

    function formatJson(jsonString) {
        try {
            return JSON.stringify(JSON.parse(jsonString), null, 2);
        } catch {
            return jsonString;
        }
    }

    // --- Test Data Management Functions ---
    async function fetchTestData() {
        const select = document.getElementById('testDataSelect');
        select.innerHTML = '<option value="">Select Test Data</option>';
        try {
            const res = await fetch('/api/testdata');
            if (!res.ok) return;
            const testDataList = await res.json();
            testDataList.forEach(data => {
                const opt = document.createElement('option');
                opt.value = data.id;
                opt.textContent = `${data.name}`;
                select.appendChild(opt);
            });
        } catch (error) {
            console.error('Failed to fetch test data:', error);
        }
    }

    async function loadTestData() {
        const select = document.getElementById('testDataSelect');
        if (!select.value) { // If "Select Test Data" (value="") is chosen
            document.getElementById('testDataName').value = '';
            document.getElementById('testDataDesc').value = '';
            document.getElementById('testDataJson').value = '';
            updateJsonPreview(); // Update preview to remove testDataId
            return;
        }
        try {
            const res = await fetch(`/api/testdata/${select.value}`);
            if (!res.ok) {
                updateJsonPreview(); // Update preview even if fetch fails (to reflect current selection)
                return;
            }
            const testData = await res.json();
            document.getElementById('testDataName').value = testData.name || '';
            document.getElementById('testDataDesc').value = testData.description || '';
            document.getElementById('testDataJson').value = formatJson(testData.dataJson);
            updateJsonPreview(); // Update preview to include/update testDataId
        } catch (error) {
            console.error('Failed to load test data:', error);
            updateJsonPreview(); // Ensure preview is updated
        }
    }

    async function saveTestData() {
        const name = document.getElementById('testDataName').value;
        const desc = document.getElementById('testDataDesc').value;
        const dataJson = document.getElementById('testDataJson').value;
        if (!name || !dataJson) {
            alert('Name and JSON data are required');
            return;
        }
        try {
            JSON.parse(dataJson); // Validate JSON
        } catch (e) {
            alert('Invalid JSON data');
            return;
        }

        const payload = {
            name: name,
            description: desc,
            dataJson: dataJson
        };

        try {
            const res = await fetch('/api/testdata', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (res.ok) {
                fetchTestData();
                alert('Test data saved successfully!');
            } else {
                alert('Failed to save test data');
            }
        } catch (error) {
            console.error('Failed to save test data:', error);
            alert('Failed to save test data');
        }
    }

    async function deleteTestData() {
        const select = document.getElementById('testDataSelect');
        if (!select.value) return;
        if (!confirm('Delete this test data?')) return;

        try {
            const res = await fetch(`/api/testdata/${select.value}`, {
                method: 'DELETE'
            });
            if (res.ok) {
                await fetchTestData();
                alert('Test data deleted successfully!');
                document.getElementById('testDataName').value = '';
                document.getElementById('testDataDesc').value = '';
                document.getElementById('testDataJson').value = '';
            } else {
                alert('Failed to delete test data');
            }
        } catch (error) {
            console.error('Failed to delete test data:', error);
            alert('Failed to delete test data');
        }
    }

    async function updateTestData() {
        const select = document.getElementById('testDataSelect');
        const testDataId = select.value;

        if (!testDataId) {
            alert('Please select a Test Data set to update.');
            return;
        }

        const name = document.getElementById('testDataName').value;
        const desc = document.getElementById('testDataDesc').value;
        const dataJson = document.getElementById('testDataJson').value;

        if (!name || !dataJson) {
            alert('Name and JSON data are required for updating.');
            return;
        }

        try {
            JSON.parse(dataJson); // Validate JSON
        } catch (e) {
            alert('Invalid JSON data. Please correct it before updating.');
            return;
        }

        const payload = {
            name: name,
            description: desc,
            dataJson: dataJson
        };

        try {
            const res = await fetch(`/api/testdata/${testDataId}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (res.ok) {
                const originalSelectedIndex = select.selectedIndex;
                await fetchTestData(); // Refresh the dropdown
                // Try to re-select the previously selected item, its text might have changed
                if (originalSelectedIndex >= 0 && originalSelectedIndex < select.options.length) {
                     // Check if the ID still exists (it should after an update)
                    const optionToReselect = Array.from(select.options).find(opt => opt.value === testDataId);
                    if (optionToReselect) {
                        select.value = testDataId;
                    } else {
                        // If ID somehow disappeared, reset selection
                        select.selectedIndex = 0;
                    }
                }
                await loadTestData(); // Reload data into form to show updated values & update JSON preview
                alert('Test data updated successfully!');
            } else {
                const errorData = await res.json().catch(() => ({ message: 'Failed to update test data. Server did not provide details.' }));
                alert(`Failed to update test data: ${errorData.message}`);
            }
        } catch (error) {
            console.error('Error updating test data:', error);
            alert('An error occurred while updating test data.');
        }
    }

    // Advanced Mode toggle logic
    function toggleAdvancedMode() {
        const showAdvanced = document.getElementById('advancedModeToggle').checked;
        document.querySelectorAll('.advanced-option').forEach(el => {
            el.style.display = showAdvanced ? '' : 'none';
        });
    }

    // Load test data on page load
    document.addEventListener('DOMContentLoaded', () => {
        fetchTestData();
        // ... existing DOMContentLoaded handlers ...
        // Ensure advanced options are hidden by default
        toggleAdvancedMode();
    });
</script>
</body>
</html>
